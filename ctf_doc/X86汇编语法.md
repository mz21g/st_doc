#### x86寄存器体系

![image-20201208155328061](C:\Users\CLAY\Desktop\st_doc\ctf_doc\image\pwn\X86寄存器体系.png)

#### 汇编基础

```assembly
; EAX EBX ECX EDX - 通用寄存器
; ESP - 堆栈指针，指向当前栈帧的栈顶（底地址）
; EBP - 基指针，指向当前栈帧的栈底（高地址）
; EIP - 指令指针，指向CPU要执行的下一条指令的地址
; 标志寄存器
; ZF - 零标志，当一个操作的结果为0时，设置为1
; CF - 进位标志，当一个操作的结果太大或者太小进而产生进位或借位时，设置为1
; SF - 负数标志，当一个操作的结果为负数时，设置为1

; 移动数据
mov ebx, eax ; 将eax的值移动到ebx
mov eax, 0xDEADBEEF ; 将0xDEADBEEF移动到eax
mov edx, DWORD PTR [0X41424344] ; 将0X41424344地址的4字节值移动到edx
mov ecx, DWORD PTR [edx] ; 将地址为edx值位置的4字节值移动到ecx
mov eax, DWORD PTR [ecx+esi*8] ; 将地址为 ecx+esi*8值位置的4字节值移动到eax

; 算术运算
sub edx, 0x11 ; edx = edx - 0x11
add eax, ebx ; eax = eax + ebx
inc edx ; edx++
dec ebx ; ebx--
xor eax, eax ; eax = eax ^ eax
or edx, 0x1337 ; edx = edx | 0x1337

; 条件跳转
jz $LOC ; 如果 ZF=1, 跳转到 $LOC
jnz $LOC ; 如果 ZF=0, 跳转到 $LOC
jg $LOC ; 如果一个比较操作的结果，destination > source， 跳转到 $LOC

; 栈操作
push ebx ; 栈指针减去4，移动到一个较低的地址，并将ebx的值复制到栈的顶部
;----------------------------------
; push ebx 可以写成:
;	sub esp, 4
;	mov DWORD PTR [esp], ebx
;----------------------------------

pop ebx ; 从栈的顶部复制值给ebx，然后栈指针加4，将它移动到一个较高的地址
;----------------------------------
; pop ebx 可以写成:
;	mov ebx, DWORD PTR [esp]
;	add esp, 4
;----------------------------------


; 调用/返回（Calling/Returning）
call some_function 
;----------------------------------
; 调用some_function处的代码，我们需要将返回地址入栈
; 	push eip -- not actually valid
;----------------------------------

ret
;---------------------------------------------
; 从函数调用处返回，将栈顶的eip出栈
; 	pop eip -- not actually valid
;---------------------------------------------

nop ; 'no operation' - does nothing
```

#### x86实战

```assembly
;---------------------------------------------
; BYTE: 字节，8位，用来储存char或者char类型指针
; WORD: 字, 16位，用来储存16为整数或者16位地址
; DWORD: 双字，32位，用来存储32位整数或32为地址
;---------------------------------------------
0x08048624: "HELLO WORLD\0"   ; 9个字节的字符串
	mov ebx, 0x08048624       ; char *ebx = "HELLO WORLD\0" 
	mov eax, 0                ; eax = 0
LOOPY:
	mov c1, BYTE PTR [ebx]    ; char c1 = *ebx
	cmp c1, 0                 ; c1 == 0
	jz end                    ; if c1 == 0, go to end
	inc eax                   ; eax++
	inc ebx                   ; ebx++
	jmp LOOPY                 ; goto LOOPY
end:
	ret                       ; return (eax位置的字符串的长度)
```

* **反汇编**

```c
char * word = "HELLO WORLD\0";
int len = 0;

while(*word != 0){
    len++;
    word++;
}

return len;
```

